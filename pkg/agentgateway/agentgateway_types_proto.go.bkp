package agentgateway

import (
	"encoding/json"
	"fmt"

	"github.com/agentgateway/agentgateway/go/api"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
)

// LocalConfig represents the main configuration structure
type LocalConfig struct {
	Binds []api.Bind `json:"binds,omitempty" yaml:"binds,omitempty"`
}

// MarshalJSON implements json.Marshaler interface for LocalConfig
func (c *LocalConfig) MarshalJSON() ([]byte, error) {
	if c == nil {
		return []byte("null"), nil
	}

	// Use protojson.MarshalOptions for configurable marshalling
	marshaler := protojson.MarshalOptions{
		UseProtoNames:     false, // Use JSON field names (camelCase) instead of proto field names
		EmitUnpopulated:   false, // Don't emit fields with zero values
		EmitDefaultValues: false, // Don't emit default values
		UseEnumNumbers:    false, // Use enum names instead of numbers
		Indent:            "",    // Compact JSON output
	}

	// Create a map to hold the JSON representation
	result := make(map[string]interface{})

	// Marshal the Binds slice
	if len(c.Binds) > 0 {
		bindsJSON := make([]interface{}, len(c.Binds))
		for i, bind := range c.Binds {
			// Check if bind implements proto.Message interface
			if msg, ok := interface{}(&bind).(proto.Message); ok {
				bindBytes, err := marshaler.Marshal(msg)
				if err != nil {
					return nil, fmt.Errorf("failed to marshal bind at index %d: %w", i, err)
				}

				var bindObj interface{}
				if err := json.Unmarshal(bindBytes, &bindObj); err != nil {
					return nil, fmt.Errorf("failed to unmarshal bind JSON at index %d: %w", i, err)
				}
				bindsJSON[i] = bindObj
			} else {
				return nil, fmt.Errorf("bind at index %d does not implement proto.Message", i)
			}
		}
		result["binds"] = bindsJSON
	}

	return json.Marshal(result)
}

// UnmarshalJSON implements json.Unmarshaler interface for LocalConfig
func (c *LocalConfig) UnmarshalJSON(data []byte) error {
	if c == nil {
		return fmt.Errorf("cannot unmarshal into nil LocalConfig")
	}

	// Use protojson.UnmarshalOptions for configurable unmarshalling
	unmarshaler := protojson.UnmarshalOptions{
		AllowPartial:   false, // Require all required fields to be present
		DiscardUnknown: false, // Don't discard unknown fields (will error instead)
	}

	// Parse the JSON into a map
	var raw map[string]interface{}
	if err := json.Unmarshal(data, &raw); err != nil {
		return fmt.Errorf("failed to unmarshal JSON: %w", err)
	}

	// Reset the struct
	*c = LocalConfig{}

	// Unmarshal the binds array
	if bindsRaw, exists := raw["binds"]; exists {
		if bindsArray, ok := bindsRaw.([]interface{}); ok {
			c.Binds = make([]api.Bind, len(bindsArray))
			for i, bindRaw := range bindsArray {
				// Convert back to JSON bytes for protojson unmarshalling
				bindBytes, err := json.Marshal(bindRaw)
				if err != nil {
					return fmt.Errorf("failed to marshal bind at index %d for protojson: %w", i, err)
				}

				// Create a new api.Bind instance
				var bind api.Bind

				// Check if bind implements proto.Message interface
				if msg, ok := interface{}(&bind).(proto.Message); ok {
					if err := unmarshaler.Unmarshal(bindBytes, msg); err != nil {
						return fmt.Errorf("failed to unmarshal bind at index %d: %w", i, err)
					}
					c.Binds[i] = bind
				} else {
					return fmt.Errorf("bind at index %d does not implement proto.Message", i)
				}
			}
		} else {
			return fmt.Errorf("binds field must be an array")
		}
	}

	return nil
}
